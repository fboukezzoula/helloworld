# Inside the loop for each subscription's VNet
for vnet in subscription_data['vnets']:
    address_spaces = vnet['address_space']
    if not address_spaces:
        logger.warning(f"Skipping VNet {vnet['name']} (no address spaces)")
        continue
    
    logger.info(f"Processing VNet {vnet['name']} with {len(address_spaces)} address spaces")
    
    peering_check = get_vnet_peerings(network_client, vnet['resource_group'], vnet['name'], config)
    logger.debug(f"Peering check for VNet {vnet['name']}: {peering_check}")
    
    # NEW: Fetch all subnets and usages for the VNet once (outside the address space loop for efficiency)
    # - Subnets: List all subnets in this VNet to calculate allocated IPs.
    # - Usages: Get usage stats (e.g., how many IPs are actually in use in each subnet).
    # This uses Azure SDK calls equivalent to 'az network vnet list-available-ips' and subnet queries.
    try:
        subnets = list(network_client.subnets.list(vnet['resource_group'], vnet['name']))
        usages = list(network_client.virtual_networks.list_usage(vnet['resource_group'], vnet['name']))
        logger.debug(f"Fetched {len(subnets)} subnets and {len(usages)} usage entries for VNet {vnet['name']}")
    except Exception as e:
        logger.warning(f"Error fetching subnets or usages for VNet {vnet['name']} in resource group {vnet['resource_group']}: {str(e)}")
        subnets = []
        usages = []
    
    # New: Get/Create Site for this VNet based on location
    vnet_location = vnet['location']
    region_data = azure_region_map.get(vnet_location)
    site_id = None
    if region_data:
        site_prefix = config.get('organization', {}).get('azure', {}).get('site_prefix', 'Azure - ')
        human_region = region_data['human_name']
        # Updated: Include shortened subscription_id in site name/slug for uniqueness
        short_sub_id = subscription_id[:8]  # First 8 characters of subscription ID
        site_name = f"{site_prefix}{short_sub_id}-{vnet['name']} ({human_region})"
        site_slug = site_name.lower().replace(" ", "-").replace("(", "").replace(")", "")
        site_desc = f"Azure VNet: {vnet['name']} in {human_region} (Subscription: {subscription_id} - {subscription_name})"
        
        site = get_or_create_site(
            nb,
            name=site_name,
            slug=site_slug,
            group_id=azure_site_group_id,
            region_id=region_data['id'],
            tenant_id=tenant_id,  # New: Assign tenant to site
            tags=region_data['tag'],  # Assign the region-specific tag (e.g., [{'id': FRC_tag_id}])
            description=site_desc
        )
        site_id = site.id if site else None
        logger.info(f"Processed Site for VNet {vnet['name']}: {site_name} (id: {site_id})")
    else:
        logger.warning(f"No region mapping found for Azure location '{vnet_location}'; skipping Site/Region for VNet {vnet['name']}")
    
    for idx, address_space in enumerate(address_spaces, 1):
        logger.debug(f"Syncing address space {idx}/{len(address_spaces)} for VNet {vnet['name']}: {address_space}")
        
        # NEW: Calculate available IPs summary for this specific address space
        # - Default to an error message if calculation fails.
        available_ips_summary = "Unable to calculate"
        try:
            # Parse the address space as an IP network to get total IPs.
            addr_net = ipaddress.ip_network(address_space, strict=False)
            total_ips = addr_net.num_addresses
            
            # Filter subnets that belong to *this* address space (a VNet can have multiple address spaces).
            subnets_in_space = [s for s in subnets if ipaddress.ip_network(s.address_prefix, strict=False).subnet_of(addr_net)]
            logger.debug(f"Found {len(subnets_in_space)} subnets in address space {address_space}")
            
            # Allocated IPs: Sum of the sizes of all subnets in this address space.
            allocated = sum(ipaddress.ip_network(s.address_prefix).num_addresses for s in subnets_in_space)
            
            # Used IPs: Sum from Azure's usage stats for these subnets.
            # (Usages include IPs actually assigned to resources like NICs, load balancers, etc.)
            used = 0
            available_in_subnets = 0
            for usage in usages:
                if '/subnets/' in usage.id:
                    subnet_name = usage.id.split('/subnets/')[-1]
                    for s in subnets_in_space:
                        if s.name == subnet_name:
                            used += usage.current_value  # IPs currently in use
                            available_in_subnets += (usage.limit - usage.current_value)  # Available within the subnet
                            break
            
            # Unallocated: IPs in the address space not yet assigned to any subnet.
            unallocated = total_ips - allocated
            
            # Total available: Unallocated + available slots within existing subnets.
            total_available = unallocated + available_in_subnets
            
            # Format the summary string (as per your example: "ips used and ips availables")
            available_ips_summary = f"Used IPs: {used}, Available IPs: {total_available}"
            logger.debug(f"Calculated summary for {address_space}: {available_ips_summary}")
        except Exception as e:
            logger.warning(f"Error calculating available IPs for {address_space} in VNet {vnet['name']}: {str(e)}")
        
        matching_aggregate = None
        try:
            prefix_net = ipaddress.ip_network(address_space, strict=False)
            for agg_prefix, agg_data in aggregate_map.items():
                agg_net = ipaddress.ip_network(agg_prefix, strict=False)
                if prefix_net.subnet_of(agg_net):
                    matching_aggregate = agg_data
                    logger.debug(f"Matched address space {address_space} to aggregate {agg_prefix}")
                    break
        except ValueError as e:
            logger.warning(f"Invalid IP network for {address_space}: {str(e)}")
            continue
        
        aggregate_id = matching_aggregate['id'] if matching_aggregate else None
        
        # FORCE assign_tenant = True to ensure EVERY prefix gets the tenant (one per subscription)
        # This ensures all prefixes for a subscription are visible under the tenant in NetBox UI.
        assign_tenant = True  # Forced to True (ignores aggregate_tag_filter for tenant assignment)
        logger.debug(f"Forcing tenant assignment for prefix {address_space} (tenant_id: {tenant_id})")
        
        prefix_tags = azure_tag_dict + additional_tags
        if matching_aggregate:
            prefix_tags += matching_aggregate['tags']
        if matching_role:
            prefix_tags += matching_role['tags']
        if region_data and region_data['tag']:
            prefix_tags += region_data['tag']  # Add region tag to prefix
        
        prefix_defaults = {
            'description': f"Azure VNet: {vnet['name']} (Subscription: {subscription_id}) - Address Space {idx}",
            'status': 'active',
            'tags': prefix_tags
        }
        if 'custom_fields' not in prefix_defaults:
            prefix_defaults['custom_fields'] = {}
        prefix_defaults['custom_fields']['peering_check'] = peering_check
        # NEW: Add the calculated summary to the new custom field.
        prefix_defaults['custom_fields']['list-available-ips'] = available_ips_summary
        
        vnet_prefix, created = get_or_create_prefix(
            nb,
            address_space,
            prefix_defaults,
            subscription_name=subscription_name,
            subscription_id=subscription_id,
            aggregate_id=aggregate_id,
            role_id=role_id,
            tenant_id=tenant_id if assign_tenant else None,
            site_id=site_id,
            tags=prefix_tags
        )
        
        action = "Created" if created else "Updated"
        logger.info(f"{action} prefix for VNet {vnet['name']} address space {idx}: {address_space} (Aggregate: {aggregate_id if aggregate_id else 'None'}, Role: {role_id if role_id else 'None'}, Tenant: {tenant_id if tenant_id else 'None'}, Site: {site_id if site_id else 'None'})")

# New: After all Azure syncing, apply inherited tags from static child prefixes
apply_inherited_tags(nb, child_tag_map)
