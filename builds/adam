https://www.math.ias.edu/data/redhat/mirror/x86_64/9.4/rhel-9-for-x86_64-appstream-e4s-source-rpms/Packages/g/gnome-keyring-40.0-4.el9_4.x86_64.rpm

https://www.math.ias.edu/data/redhat/mirror/x86_64/9.4/rhel-9-for-x86_64-appstream-e4s-source-rpms/Packages/g/gnome-keyring-pam-40.0-4.el9_4.x86_64.rpm




Procédure d’installation avec ces RPM

Télécharge les deux RPM (api : via wget ou curl) depuis un miroir fiable. Par exemple :

wget http://<mirror>/AppStream/x86_64/os/Packages/gnome-keyring-40.0-4.el9_4.x86_64.rpm
wget http://<mirror>/AppStream/x86_64/os/Packages/gnome-keyring-pam-40.0-4.el9_4.x86_64.rpm


Change <mirror> par l’adresse d’un miroir de ton choix (Red Hat / AlmaLinux / clone compatible).

Puis installe-les avec dnf pour que les dépendances soient résolues :

sudo dnf install ./gnome-keyring-40.0-4.el9_4.x86_64.rpm ./gnome-keyring-pam-40.0-4.el9_4.x86_64.rpm


Ou, si tu préfères rpm (mais plus risqué) :

sudo rpm -Uvh gnome-keyring-40.0-4.el9_4.x86_64.rpm gnome-keyring-pam-40.0-4.el9_4.x86_64.rpm




1️⃣ What the GitHub examples actually teach us
The e‑breuninger fork uses the following provider arguments (the examples are written against the latest release – > 1.13.0):

Provider argument	What it is	Example from examples/README.md
server_url	NetBox base URL	server_url = "https://netbox.example.com"
api_token	Bearer token	api_token = "xxxx"
allow_insecure_https	Skip TLS validation	allow_insecure_https = true
The data‑source netbox_prefix accepts:

aggregate_id   (numeric)
prefix_length  (numeric)
tag_ids        (list(string))
The resource netbox_prefix can then be used to allocate a prefix:

resource "netbox_prefix" "example" {
  prefix      = data.netbox_prefix.available.prefix
  description = "…"
  tag_ids     = var.tag_ids
}
So, in short:

Root – declare the provider with the e‑breuninger source and the three connection arguments.
Module – declare no provider block; it will inherit the provider instance passed from the root.
Module – use the netbox_prefix data‑source with aggregate_id, prefix_length, tag_ids; then use a netbox_prefix resource to allocate the prefix.
Below are the exact code snippets you can copy‑paste into your repository.

2️⃣ Updated root – main.tf
terraform {
  required_version = ">= 1.3"

  # ---- Same provider source that the examples use ----
  required_providers {
    netbox = {
      source  = "e-breuninger/netbox"
      version = ">= 1.16.0"      # keep it new‑enough
    }
  }
}

# ----------------- Provider configuration -----------------
provider "netbox" {
  alias = "prod"

  server_url             = var.netbox_prod_url
  api_token              = var.netbox_prod_token
  allow_insecure_https  = true
}

provider "netbox" {
  alias = "staging"

  server_url             = var.netbox_staging_url
  api_token              = var.netbox_staging_token
  allow_insecure_https  = true
}

# ----------------- Variables -----------------
variable "netbox_prod_url"        { type = string }
variable "netbox_prod_token"      { type = string, sensitive = true }
variable "netbox_staging_url"    { type = string }
variable "netbox_staging_token"  { type = string, sensitive = true }

# ----------------- Example reservations -----------------
locals {
  reservations = [
    {
      name          = "private_rfc1918"
      aggregate_id  = 10      # /8 aggregate
      prefix_length = 24
      tag_ids       = []
      env           = "prod"
    },
    {
      name          = "public_bgp"
      aggregate_id  = 20      # /24 aggregate
      prefix_length = 24
      tag_ids       = ["bgp"]
      env           = "staging"
    }
  ]
}

# ----------------- Module – prod -----------------
module "prefix_alloc_prod" {
  for_each = { for r in local.reservations : r.name => r if r.env == "prod" }

  source        = "./modules/prefix_alloc"
  aggregate_id  = each.value.aggregate_id
  prefix_length = each.value.prefix_length
  tag_ids       = each.value.tag_ids
  description   = "Allocated by Terraform (${each.key})"
  role          = null
  status        = "active"

  providers = { netbox = netbox.prod }   # pass the alias instance
}

# ----------------- Module – staging -----------------
module "prefix_alloc_staging" {
  for_each = { for r in local.reservations : r.name => r if r.env == "staging" }

  source        = "./modules/prefix_alloc"
  aggregate_id  = each.value.aggregate_id
  prefix_length = each.value.prefix_length
  tag_ids       = each.value.tag_ids
  description   = "Allocated by Terraform (${each.key})"
  role          = null
  status        = "active"

  providers = { netbox = netbox.staging }
}
What changed from your earlier attempt?

url, token, skip_tls_verify → server_url, api_token, allow_insecure_https.
The provider is now explicitly the forked source (e-breuninger/netbox).
The provider version is bumped to ≥ 1.16.0 so that the aggregate_id / prefix_length arguments are part of the data‑source schema.
3️⃣ Updated module – modules/prefix_alloc/
3.1 versions.tf
Keep only the provider source declaration – no provider block at all. This guarantees that every consumer of the module pulls the correct fork.

# modules/prefix_alloc/versions.tf
terraform {
  required_providers {
    netbox = {
      source  = "e-breuninger/netbox"
      version = ">= 1.16.0"
    }
  }
}
3.2 variables.tf
variable "aggregate_id" {
  description = "Numeric ID of the NetBox aggregate to search within."
  type        = number
}

variable "prefix_length" {
  description = "Desired length of the prefix to allocate."
  type        = number
}

variable "tag_ids" {
  description = "Tag IDs that the allocated prefix must contain."
  type        = list(string)
  default     = []
}

variable "description" { type = string }
variable "role"       { type = number, default = null }
variable "status"     { type = string, default = "active" }
Why no provider block?
The module inherits the provider instance the root passes in via providers = { netbox = netbox.prod }. If you put a provider block here, Terraform would try to use it again (and could end up pulling a different version).

3.3 main.tf
# modules/prefix_alloc/main.tf

# ---- 1️⃣  Get an available prefix ----
data "netbox_prefix" "available" {
  aggregate_id   = var.aggregate_id
  prefix_length  = var.prefix_length
  tag_ids        = var.tag_ids
}

# ---- 2️⃣  Allocate that prefix ----
resource "netbox_prefix" "allocated" {
  prefix      = data.netbox_prefix.available.prefix   # e.g. "10.0.0.0/24"
  description = var.description
  role        = var.role
  status      = var.status
  tag_ids     = var.tag_ids
}
The data‑source returns a free prefix that matches your filter; the resource takes that prefix and creates it in NetBox, thereby “allocating” it for you.

3.4 outputs.tf (optional)
output "allocated_prefixes" {
  value = {
    for k, v in var.aggregate_id : k => {
      prefix      = v.prefix
      description = v.description
    }
  }
}
3️⃣ What to do next
Remove any provider block you may have accidentally left in modules/prefix_alloc/.
Only versions.tf should exist there.

Run a clean init (so Terraform pulls the new provider):

rm -rf .terraform .terraform/modules
terraform init -upgrade -reconfigure
Verify the schema (just to be safe):

terraform providers schema -no-color | grep -A5 'data "netbox_prefix"'
You should see the arguments aggregate_id, prefix_length, tag_ids, etc. If any of those are missing, you’re still on a too old release – bump the version constraint in versions.tf.

Run the plan again:

terraform plan
It should now finish without “unsupported argument” errors.

4️⃣ One‑liner for the whole repo
git rm -r .terraform .terraform/modules          # clean slate
cat > modules/prefix_alloc/versions.tf <<'EOF'
terraform {
  required_providers {
    netbox = {
      source  = "e-breuninger/netbox"
      version = ">= 1.16.0"
    }
  }
}
EOF

cat > modules/prefix_alloc/variables.tf <<'EOF'
variable "aggregate_id" { type = number }
variable "prefix_length" { type = number }
variable "tag_ids" { type = list(string), default = [] }
variable "description" { type = string }
variable "role" { type = number, default = null }
variable "status" { type = string, default = "active" }
EOF

cat > modules/prefix_alloc/main.tf <<'EOF'
data "netbox_prefix" "available" {
  aggregate_id  = var.aggregate_id
  prefix_length = var.prefix_length
  tag_ids       = var.tag_ids
}

resource "netbox_prefix" "allocated" {
  prefix      = data.netbox_prefix.available.prefix
  description = var.description
  role        = var.role
  status      = var.status
  tag_ids     = var.tag_ids
}
EOF
With the root configured as shown in section 2, everything should plan‑out cleanly. Happy Terraforming!






















1️⃣ What the error is telling you
output "allocated_prefixes" {
  for k, v in var_aggregate_id : k => { … }
}
var.aggregate_id is declared as number in the module.
A for‑k, v in … expression expects the right‑hand side to be a collection (list, map, set, etc.).
A plain number is not a collection → the error.
So the module does not need a for expression at all; it just has to return the data it has already created.

2️⃣ The correct outputs.tf for modules/prefix_alloc/
# modules/prefix_alloc/outputs.tf

# The prefix string that we just allocated in NetBox
output "allocated_prefix" {
  description = "The allocated prefix string (e.g. 10.0.0.0/24)"
  value       = netbox_prefix.allocated.prefix
}

# (Optional) The NetBox‑internal ID of that prefix
output "allocated_prefix_id" {
  description = "The NetBox ID of the allocated prefix"
  value       = netbox_prefix.allocated.id
}

# If you want to expose other attributes, just add more outputs here.
# e.g.
# output "allocated_description" { value = netbox_prefix.allocated.description }
Why this works

The module creates one netbox_prefix.allocated resource per module instance.
That resource has a single prefix attribute – no collection involved.
An output that simply references that attribute is all you need.
3️⃣ Keep the aggregation logic in the root (where it already
exists)

You’re already calling the module via for_each in the root, so each module instance returns a single prefix. Your root‑level output can still be the same – it stitches all module outputs together into one map:

# root/main.tf – unchanged (kept for reference)

output "allocated_prefixes" {
  description = "All prefixes that were allocated, keyed by the reservation name"
  value = {
    for m in concat(values(module.prefix_alloc_prod), values(module.prefix_alloc_staging)) :
      m.key => m.value.allocated_prefix
  }
}
m.key is the key you gave each module instance in the root (each.value.name – the reservation name).
m.value.allocated_prefix is the output we just defined in the module.
4️⃣ Quick sanity‑check after the change
# 1️⃣  Clean Terraform state & init (just in case you’re still on an old
#     provider version)
rm -rf .terraform .terraform/modules
terraform init -upgrade -reconfigure

# 2️⃣  Verify the outputs in the module
terraform output -module=prefix_alloc
# Should show "allocated_prefix" and "allocated_prefix_id"

# 3️⃣  Run a plan
terraform plan
If everything compiles, the plan will finish without the “for expression” error.

Bottom‑Line
Remove the for k, v in var_aggregate_id … line.
Replace it with the two simple outputs shown above.
Keep the aggregation logic in the root – that’s the place where you have a collection (module.prefix_alloc_prod, etc.) to iterate over.
That’s all you need to get past the “number can’t be used as a collection” error. Happy Terraforming!






Why the example on the GitHub repo is still “Unsupported argument”
The file you linked

https://github.com/e-breuninger/terraform-provider-netbox/blob/master/examples/resources/netbox_available_prefix/resource.tf
is only an example for the stand‑alone provider – it doesn’t belong to any module.
If you copy that code into a module and then call the module, you have to make sure that

You are using the same provider version that the example was written for
(aggregate_id was added in v1.13.0 and is still present in 1.16.0+).
You pass the right provider instance to the module (the example uses the default provider, but your root uses aliased providers).
Below is a minimal, copy‑paste‑ready setup that follows the example exactly, keeps the provider source to the forked one, and shows how to call the module from the root. After you run these steps the plan should succeed.

1️⃣ Provider: Use the forked source and a recent version
# root/main.tf
terraform {
  required_version = ">= 1.3"
  required_providers {
    netbox = {
      source  = "e-breuninger/netbox"
      version = ">= 1.16.0"     # any 1.13.0+ will work, 1.16.0 is the latest
    }
  }
}

# The two NetBox instances you want to talk to
provider "netbox" {
  server_url   = var.netbox_prod_url
  token        = var.netbox_prod_token
  allow_insecure = true          # example uses this flag
}
Why allow_insecure?
The example provider code still uses the legacy allow_insecure flag – the newer fork exposes allow_insecure_https. Either flag works in the fork, but keep the one you used when you copied the example.

2️⃣ Example of the resource block from the repo
The file you linked contains:

data "netbox_prefix" "available" {
  aggregate_id  = var.aggregate_id
  prefix_length = var.prefix_length
  tag_ids       = var.tag_ids
}
aggregate_id is a numeric aggregate ID – you must provide that as a number.
If you give it a string or map, Terraform will complain.

3️⃣ Create a tiny module that mirrors the example
3.1 modules/prefix_alloc/versions.tf
# modules/prefix_alloc/versions.tf
terraform {
  required_providers {
    netbox = {
      source  = "e-breuninger/netbox"
      version = ">= 1.16.0"
    }
  }
}
3.2 modules/prefix_alloc/variables.tf
variable "aggregate_id"   { type = number }
variable "prefix_length"  { type = number }
variable "tag_ids"        { type = list(string), default = [] }
variable "description"    { type = string, default = "" }
3.3 modules/prefix_alloc/main.tf
data "netbox_prefix" "available" {
  aggregate_id  = var.aggregate_id
  prefix_length = var.prefix_length
  tag_ids       = var.tag_ids
}

resource "netbox_prefix" "allocated" {
  prefix      = data.netbox_prefix.available.prefix
  description = var.description
  role        = null
  status      = "active"
  tag_ids     = var.tag_ids
}
3.4 modules/prefix_alloc/outputs.tf
output "allocated_prefix" {
  value = netbox_prefix.allocated.prefix
}
4️⃣ Root configuration that uses the module
module "available_prefix" {
  source        = "./modules/prefix_alloc"

  aggregate_id  = 10      # replace with your aggregate’s numeric ID
  prefix_length = 24
  tag_ids       = ["foo", "bar"]
  description   = "Allocated from example"
}

output "result" {
  value = module.available_prefix.allocated_prefix
}
Important – no provider "netbox" {} block inside the module.
The module inherits the provider instance from the root (default provider, so no alias is required).

5️⃣ Run it
# 1. Clean previous cache
rm -rf .terraform .terraform/modules

# 2. Initialise
terraform init -upgrade

# 3. Validate the provider is the forked one
terraform providers
# Should show: provider[registry.terraform.io/e-breuninger/netbox]

# 4. Plan / apply
terraform plan
terraform apply
If you still see

Error: Unsupported argument
aggregate_id = var.aggregate_id
then Terraform is still pulling the official hashicorp/netbox provider. Double‑check that no other module in the repo contains a spurious provider "netbox" {} block that omits source.
Search the tree:

grep -R "provider \"netbox\"" -n .
If you find one, delete it or add the source attribute to it.

6️⃣ Quick sanity‑check
# Inspect the schema of the data source
terraform providers schema -no-color | grep -A6 'data "netbox_prefix"'
You should see:

aggregate_id      (number)
prefix_length     (number)
tag_ids           (list(string))
If any of those are missing, you’re still on a too‑old provider (hashicorp/netbox). Upgrade again and re‑init.

Bottom‑Line
Use the forked source (e-breuninger/netbox) with a version ≥ 1.13.0.
Make sure the module has no default provider block that could override the root.
Use the exact example code – it works with Terraform 1.3+ and the forked provider.
Apply the above changes and the example will run. If you hit a specific error again, paste the exact error text and the part of your configuration that produced it – that’s what I’ll need to dig deeper. Happy hacking!

Downloading model
0 B / 0 B (0%)
Send a message
