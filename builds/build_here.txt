/terraform-netbox
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îú‚îÄ‚îÄ outputs.tf
‚îî‚îÄ‚îÄ modules
    ‚îî‚îÄ‚îÄ prefix_alloc
        ‚îú‚îÄ‚îÄ main.tf
        ‚îú‚îÄ‚îÄ variables.tf
        ‚îî‚îÄ‚îÄ outputs.tf


2Ô∏è‚É£ Fichier racine‚ÄØ: main.tf
terraform {
  required_version = ">= 1.3"
  required_providers {
    netbox = {
      source  = "cloudnativeapp/terraform-provider-netbox"
      version = ">= 0.19.0"   # version qui supporte NetBox 4.3.x
    }
  }
}

provider "netbox" {
  # URL de votre instance NetBox (ici locale)
  url = var.netbox_url

  # Token d‚ÄôAPI fourni par NetBox
  token = var.netbox_token

  # On ignore les erreurs SSL (localhost sans certificat CA)
  skip_tls_verify = true
}

# Appel du module d‚Äôallocation de prefix
module "prefix_alloc" {
  source = "./modules/prefix_alloc"

  # Id de l‚Äôaggregate (ou du prefix parent) dans lequel on veut r√©server
  aggregate_id = var.aggregate_id

  # Taille du prefix √† allouer
  prefix_length = var.prefix_length

  # Tags (nom ou id) que l‚Äôon veut filtrer et appliquer
  tag_ids = var.tag_ids

  # Descriptif et autres options de la nouvelle allocation
  description = var.description
  role        = var.role
  status      = var.status
}

# Optionnel : exporter les valeurs retourn√©es par le module
output "allocated_prefix" {
  value = module.prefix_alloc.allocated_prefix
}

output "allocated_prefix_id" {
  value = module.prefix_alloc.allocated_prefix_id
}

3Ô∏è‚É£ Variables racine‚ÄØ: variables.tf
variable "netbox_url" {
  description = "URL de l‚Äôinstance NetBox (ex : http://localhost:2025)"
  type        = string
  default     = "http://localhost:2025"
}

variable "netbox_token" {
  description = "Token API NetBox"
  type        = string
  sensitive   = true
  default     = "3bac96ea-940b-444a-9757-a9a000282db3"   # √† remplacer par votre token
}

variable "aggregate_id" {
  description = "ID de l‚Äôaggregate (ou du prefix parent) o√π r√©server"
  type        = number
}

variable "prefix_length" {
  description = "Longueur du prefix √† allouer (ex : 24 pour /24)"
  type        = number
  default     = 24
}

variable "tag_ids" {
  description = "Liste des tags (nom ou id) qui doivent √™tre pr√©sents sur le prefix parent et appliqu√©s au nouveau prefix"
  type        = list(string)
  default     = []
}

# Valeurs suppl√©mentaires du prefix allou√©
variable "description" {
  description = "Description du prefix allou√©"
  type        = string
  default     = "Prefix allou√© automatiquement par Terraform"
}

variable "role" {
  description = "R√¥le du prefix (facultatif)"
  type        = string
  default     = null
}

variable "status" {
  description = "Statut du prefix (facultatif, ex : active)"
  type        = string
  default     = null
}
Note
Vous pouvez passer les tags par nom (ex‚ÄØ: "commercial") ou par id (ex‚ÄØ: "12").
Si vous ne voulez pas filtrer sur des tags, laissez tag_ids = [].

4Ô∏è‚É£ Module d‚Äôallocation‚ÄØ: modules/prefix_alloc/main.tf
# 4Ô∏è‚É£ 1Ô∏è‚É£ Rechercher le prefix disponible
data "netbox_prefix" "available_prefix" {
  # on veut un prefix non encore utilis√©
  available = true

  # on se place dans l‚Äôaggregate / prefix parent
  container = var.aggregate_id

  # on veut une longueur exacte (ex : /24)
  length = var.prefix_length

  # filtre sur les tags qui doivent √™tre pr√©sents sur le prefix parent
  tags = var.tag_ids
}

# 4Ô∏è‚É£ 2Ô∏è‚É£ Cr√©er le prefix
resource "netbox_prefix" "allocated" {
  prefix = data.netbox_prefix.available_prefix.prefix

  description = var.description
  role        = var.role
  status      = var.status

  # on applique les m√™mes tags au prefix allou√©
  tags = var.tag_ids
}
5Ô∏è‚É£ Variables du module‚ÄØ: modules/prefix_alloc/variables.tf
variable "aggregate_id" {
  description = "ID de l‚Äôaggregate / prefix parent"
  type        = number
}

variable "prefix_length" {
  description = "Longueur du prefix √† allouer"
  type        = number
}

variable "tag_ids" {
  description = "Liste de tags (nom ou id) √† filtrer et √† appliquer"
  type        = list(string)
  default     = []
}

variable "description" {
  description = "Description du prefix allou√©"
  type        = string
  default     = "Prefix allou√© automatiquement par Terraform"
}

variable "role" {
  description = "R√¥le du prefix (facultatif)"
  type        = string
  default     = null
}

variable "status" {
  description = "Statut du prefix (facultatif, ex : active)"
  type        = string
  default     = null
}
6Ô∏è‚É£ Sorties du module‚ÄØ: modules/prefix_alloc/outputs.tf
output "allocated_prefix" {
  description = "Le prefix allou√© (ex‚ÄØ: 192.168.10.0/24)"
  value       = netbox_prefix.allocated.prefix
}

output "allocated_prefix_id" {
  description = "ID NetBox du prefix allou√©"
  value       = netbox_prefix.allocated.id
}
7Ô∏è‚É£ Comment ex√©cuter

# 1Ô∏è‚É£ Initialiser le r√©pertoire Terraform (t√©l√©charge les providers)
terraform init

# 2Ô∏è‚É£ V√©rifier le plan (voir ce qui sera cr√©√©)
terraform plan -var="aggregate_id=12" -var="tag_ids=[\"commercial\"]"

# 3Ô∏è‚É£ Appliquer le plan
terraform apply -var="aggregate_id=12" -var="tag_ids=[\"commercial\"]"
Remplacez aggregate_id par l‚ÄôID de votre aggregate ou du prefix parent.
tag_ids peut √™tre vide ou contenir un ou plusieurs tags qui sont d√©j√† associ√©s √† ce prefix parent.

8Ô∏è‚É£ R√©sum√© rapide
√âtape	Fichier	Contenu cl√©
1	provider	URL, token, skip_tls_verify = true
2	data "netbox_prefix"	available = true, container = aggregate_id, length = 24, tags = ‚Ä¶
3	resource "netbox_prefix"	prefix = data.netbox_prefix.available_prefix.prefix, description, tags
4	module	Regroupe le 2 & 3, expose allocated_prefix et allocated_prefix_id
Vous avez maintenant un template Terraform complet et pr√™t √† l‚Äôemploi pour r√©server un CIDR /24 dans votre NetBox 4.3.3, tout en filtrant sur les tags du prefix parent. Bon d√©ploiement‚ÄØ!






Utiliser un token d‚Äôenvironnement avec Terraform
1Ô∏è‚É£ Le principe
Terraform lit automatiquement les variables d‚Äôenvironnement qui suivent la convention

TF_VAR_<nom_de_la_variable> = <valeur>
Par exemple, pour la variable d√©clar√©e‚ÄØ:

variable "netbox_token" {
  description = "Token API NetBox"
  type        = string
  sensitive   = true
}
vous pouvez la fournir depuis votre shell‚ÄØ:

export TF_VAR_netbox_token="3bac96ea-940b-444a-9757-a9a000282db3"
Et Terraform l‚Äôutilisera sans que vous ayez besoin d‚Äôun default dans le fichier variables.tf.

2Ô∏è‚É£ Mise √† jour du fichier variables.tf
variable "netbox_token" {
  description = "Token d‚ÄôAPI NetBox (peut √™tre fourni via TF_VAR_netbox_token ou -var)"
  type        = string
  sensitive   = true
}
Remarque
Si vous laissez la variable sans valeur par d√©faut, Terraform vous signalera une erreur lors de l‚Äôex√©cution s‚Äôil n‚Äôy a aucune valeur fournie (environnement, fichier .tfvars, -var, etc.).
C‚Äôest exactement ce qu‚Äôon veut : vous ne voulez pas laisser le token dans le code source.

3Ô∏è‚É£ Exemple complet (avec le module d‚Äôallocation)
# main.tf
terraform {
  required_version = ">= 1.3"
  required_providers {
    netbox = {
      source  = "cloudnativeapp/terraform-provider-netbox"
      version = ">= 0.19.0"
    }
  }
}

provider "netbox" {
  url             = var.netbox_url
  token           = var.netbox_token
  skip_tls_verify = true
}

module "prefix_alloc" {
  source       = "./modules/prefix_alloc"
  aggregate_id = var.aggregate_id
  prefix_length= var.prefix_length
  tag_ids      = var.tag_ids
  description  = var.description
  role         = var.role
  status       = var.status
}

output "allocated_prefix" {
  value = module.prefix_alloc.allocated_prefix
}

output "allocated_prefix_id" {
  value = module.prefix_alloc.allocated_prefix_id
}
# variables.tf
variable "netbox_url" {
  description = "URL de l‚Äôinstance NetBox"
  type        = string
  default     = "http://localhost:2025"
}

variable "netbox_token" {
  description = "Token d‚ÄôAPI NetBox (√† mettre dans TF_VAR_netbox_token)"
  type        = string
  sensitive   = true
}

variable "aggregate_id" {
  description = "ID de l‚Äôaggregate / prefix parent"
  type        = number
}

variable "prefix_length" {
  description = "Longueur du prefix √† allouer (ex : 24 pour /24)"
  type        = number
  default     = 24
}

variable "tag_ids" {
  description = "Liste de tags (nom ou id) √† filtrer et √† appliquer"
  type        = list(string)
  default     = []
}

variable "description" {
  description = "Description du prefix allou√©"
  type        = string
  default     = "Prefix allou√© automatiquement par Terraform"
}

variable "role" {
  description = "R√¥le du prefix (facultatif)"
  type        = string
  default     = null
}

variable "status" {
  description = "Statut du prefix (facultatif, ex : active)"
  type        = string
  default     = null
}
4Ô∏è‚É£ Ex√©cution
# 1Ô∏è‚É£ Exporter le token (une seule fois par session)
export TF_VAR_netbox_token="3bac96ea-940b-444a-9757-a9a000282db3"

# 2Ô∏è‚É£ Initialiser Terraform (t√©l√©charge les providers)
terraform init

# 3Ô∏è‚É£ V√©rifier le plan
terraform plan -var="aggregate_id=12" -var="tag_ids=[\"commercial\"]"

# 4Ô∏è‚É£ Appliquer le plan
terraform apply -var="aggregate_id=12" -var="tag_ids=[\"commercial\"]"
S√©curit√©
Le token est marqu√© sensitive, donc il ne sera pas affich√© dans la sortie de terraform plan ou apply.
Il ne sera pas enregistr√© dans le fichier terraform.tfstate non plus, ce qui √©vite toute fuite accidentelle.

üéâ R√©sum√©
Supprimez le default du netbox_token.
Exportez la variable d‚Äôenvironnement TF_VAR_netbox_token.
Terraform l‚Äôutilisera automatiquement, sans que le token soit cod√© en clair dans vos fichiers.
Vous avez maintenant un template s√©curis√© et pr√™t √† l‚Äôemploi‚ÄØ!




***********************************************************************


üöÄ‚ÄØR√©server plusieurs CIDR (un /24 par d√©faut) issus d‚Äôagregats diff√©rents
1Ô∏è‚É£ Pourquoi on ne peut pas faire √ßa dans le m√™me bloc resource ?
netbox_prefix (ou tout provider) ne permet qu‚Äôune seule requ√™te‚ÄØ: ¬´‚ÄØcherche le prefix disponible‚ÄØ¬ª‚ÄØ.
Si vous avez deux aggregates (ex‚ÄØ: 10.0.0.0/8 et 203.0.113.0/24) vous devez lancer deux requ√™tes distinctes‚ÄØ: une pour chaque aggregate.

2Ô∏è‚É£ Deux approches
Approche	Avantages	Inconv√©nients
Deux appels du m√™me module (un module par aggregate)	Lisible, chaque bloc est ind√©pendant	Du code r√©p√©t√© si vous avez beaucoup d‚Äôaggregates
Un seul module appel√© for_each	Un seul bloc de code, facilement extensible	Un peu plus de logique dans le module
Nous allons pr√©senter la seconde approche, qui est la plus ¬´‚ÄØ√©volutive‚ÄØ¬ª.
üì¶ Arborescence modifi√©e
/terraform-netbox
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îú‚îÄ‚îÄ outputs.tf
‚îî‚îÄ‚îÄ modules
    ‚îî‚îÄ‚îÄ prefix_alloc
        ‚îú‚îÄ‚îÄ main.tf
        ‚îú‚îÄ‚îÄ variables.tf
        ‚îî‚îÄ‚îÄ outputs.tf
Note : Le module prefix_alloc reste inchang√© (il r√©serve un seul /24 √† la fois).
Ce qui change, c‚Äôest la fa√ßon dont on l‚Äôappelle dans main.tf.

üîß main.tf (racine)
terraform {
  required_version = ">= 1.3"
  required_providers {
    netbox = {
      source  = "cloudnativeapp/terraform-provider-netbox"
      version = ">= 0.19.0"
    }
  }
}

provider "netbox" {
  url             = var.netbox_url
  token           = var.netbox_token
  skip_tls_verify = true
}

# ‚îÄ‚îÄ 1Ô∏è‚É£  D√©finition de la liste des r√©servations
# chaque entr√©e est un *map* contenant le nom de l‚Äôagg + les options
locals {
  reservations = [
    # 1Ô∏è‚É£ R√©servation dans un aggregate RFC‚Äë1918
    {
      name          = "private_rfc1918"
      aggregate_id  = 10   # ID de 10.0.0.0/8 dans NetBox
      prefix_length = 24
      tag_ids       = []        # pas de tags √† filtrer
    },
    # 2Ô∏è‚É£ R√©servation dans un aggregate BGP public
    {
      name          = "bgp_public"
      aggregate_id  = 20   # ID de 203.0.113.0/24 dans NetBox
      prefix_length = 24
      tag_ids       = ["bgp"]
    }
  ]
}

# ‚îÄ‚îÄ 2Ô∏è‚É£  Instanciation du module *pour chaque reservation*
module "prefix_alloc" {
  for_each = { for r in local.reservations : r.name => r }

  source       = "./modules/prefix_alloc"
  aggregate_id = each.value.aggregate_id
  prefix_length= each.value.prefix_length
  tag_ids      = each.value.tag_ids
  description  = "Allocated by Terraform (${each.key})"
  role         = null
  status       = "active"
}

# ‚îÄ‚îÄ 3Ô∏è‚É£  Exports (facultatif)
output "allocated_prefixes" {
  description = "Map de nom => CIDR allou√©"
  value = { for k, m in module.prefix_alloc : k => m.allocated_prefix }
}

output "allocated_prefix_ids" {
  description = "Map de nom => ID NetBox du prefix allou√©"
  value = { for k, m in module.prefix_alloc : k => m.allocated_prefix_id }
}
Explications
locals.reservations
Une liste de maps, chaque map repr√©sente une r√©servation‚ÄØ:

name ‚Äì nom cl√© (sera utilis√© comme cl√© for_each)
aggregate_id ‚Äì ID du parent (aggregate ou prefix container)
prefix_length ‚Äì longueur voulue (24 par d√©faut)
tag_ids ‚Äì tags √† filtrer (facultatif)
for_each
Cr√©e une instance du module par entr√©e.
each.key = name ; each.value = la map compl√®te.

Outputs
On exporte un map de nom ‚Üí CIDR, ce qui est tr√®s utile dans d‚Äôautres modules ou scripts.

üõ†Ô∏è Le module prefix_alloc (inchang√©)
# modules/prefix_alloc/main.tf
data "netbox_prefix" "available_prefix" {
  available = true
  container = var.aggregate_id
  length    = var.prefix_length
  tags      = var.tag_ids
}

resource "netbox_prefix" "allocated" {
  prefix      = data.netbox_prefix.available_prefix.prefix
  description = var.description
  role        = var.role
  status      = var.status
  tags        = var.tag_ids
}
# modules/prefix_alloc/variables.tf
variable "aggregate_id"   { type = number }
variable "prefix_length"  { type = number }
variable "tag_ids"        { type = list(string); default = [] }
variable "description"    { type = string }
variable "role"           { type = string; default = null }
variable "status"         { type = string; default = null }
# modules/prefix_alloc/outputs.tf
output "allocated_prefix"     { value = netbox_prefix.allocated.prefix }
output "allocated_prefix_id"  { value = netbox_prefix.allocated.id }
üéØ Cas d‚Äôutilisation : une seule ou plusieurs r√©servations
Une seule reservation :
Simplifiez locals.reservations √† une entr√©e unique (ou utilisez count/for_each avec une liste de taille‚ÄØ1).
L‚Äôappel du module est identique, mais il n‚Äôy aura qu‚Äôune seule instance.

Plusieurs r√©servations :
Ajoutez simplement plus de maps dans locals.reservations.
Le code reste le m√™me‚ÄØ; Terraform cr√©e automatiquement autant d‚Äôinstances que besoin.

‚öôÔ∏è Commandes
# 1Ô∏è‚É£ Initialiser le r√©pertoire (une fois)
terraform init

# 2Ô∏è‚É£ Voir le plan (vous verrez 2 ressources `netbox_prefix.allocated`)
terraform plan

# 3Ô∏è‚É£ Appliquer
terraform apply
üìö En r√©sum√©
Chaque prefix doit √™tre r√©serv√© depuis son propre aggregate.
Utilisez une instance du module par aggregate (for_each ou count).
Passez la liste de r√©servations dans un local ou un variable (list(object({...}))).
Le module reste simple, seul responsable de r√©server un /24.
Les outputs en map vous permettent de r√©f√©rencer les prefixes allou√©s dans d‚Äôautres ressources ou scripts.
Vous avez maintenant un template Terraform pr√™t √† g√©rer toutes les combinaisons d‚Äôaggregats et de CIDR. Happy provisioning‚ÄØ!

Downloading model
0 B / 0 B (0%)


Downloading model

