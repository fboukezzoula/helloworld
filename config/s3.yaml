apiVersion: v1wRE1lDr7sT1b?s$92uYl
kind: Pod
metadata:
  name: s3fs-app
spec:
  volumes:
    - name: s3-bucket
      emptyDir: {}   # volume partag√© entre init et app

    - name: fuse-device
      hostPath:
        path: /dev/fuse
        type: CharDevice

  initContainers:
    - name: s3-mounter
      image: quay.io/efrecon/s3fs:latest
      securityContext:
        runAsUser: 0
        runAsGroup: 0
        capabilities:
          add: ["SYS_ADMIN", "DAC_READ_SEARCH"]
        allowPrivilegeEscalation: false
      env:
        - name: AWSACCESSKEYID
          valueFrom:
            secretKeyRef:
              name: s3-credentials
              key: accessKey
        - name: AWSSECRETACCESSKEY
          valueFrom:
            secretKeyRef:
              name: s3-credentials
              key: secretKey
      command:
        - "sh"
        - "-c"
        - |
          mkdir -p /mnt/s3
          s3fs my-bucket /mnt/s3 \
            -o url=https://s3.amazonaws.com \
            -o use_path_request_style \
            -o allow_other \
            -o nonempty
          # Garder le processus en vie tant que l'app tourne
          sleep 3600
      volumeMounts:
        - mountPath: /mnt/s3
          name: s3-bucket
        - mountPath: /dev/fuse
          name: fuse-device

  containers:
    - name: app
      image: debian:bookworm-slim
      command: ["sleep", "infinity"]
      securityContext:
        runAsUser: 1000    # ton user app
        runAsGroup: 1000
        allowPrivilegeEscalation: false
      volumeMounts:
        - mountPath: /data
          name: s3-bucket
















          # Base UBI 9
FROM registry.access.redhat.com/ubi9/ubi:9.3

# Installer d√©pendances et s3fs-fuse
RUN dnf install -y \
      epel-release \
      fuse \
      fuse-libs \
      s3fs-fuse \
    && dnf clean all

# Cr√©er un utilisateur applicatif non-root
RUN useradd -m appuser

# R√©pertoire de montage
RUN mkdir /mnt/s3 && chown appuser:appuser /mnt/s3

USER appuser

ENTRYPOINT ["sleep", "infinity"]










On va donc compl√©ter ton Pod pour que ton container app monte directement le WebDAV expos√© par le sidecar rclone sur un r√©pertoire /data.
Ainsi ton app voit /data comme un disque normal, et tout est stock√© dans S3.

üöÄ Exemple Kubernetes Pod avec WebDAV mont√© dans /data
apiVersion: v1
kind: Pod
metadata:
  name: app-with-s3-mount
spec:
  containers:
    # --- Sidecar rclone (expose S3 en WebDAV) ---
    - name: rclone
      image: rclone/rclone:latest
      args:
        - serve
        - webdav
        - --addr=:8080
        - s3:my-bucket
      env:
        - name: AWS_ACCESS_KEY_ID
          valueFrom:
            secretKeyRef:
              name: s3-credentials
              key: accessKey
        - name: AWS_SECRET_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              name: s3-credentials
              key: secretKey
      ports:
        - containerPort: 8080

    # --- Application avec montage WebDAV ---
    - name: app
      image: registry.access.redhat.com/ubi9/ubi:9.3
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
      command:
        - sh
        - -c
        - |
          dnf install -y davfs2 && \
          mkdir -p /data && \
          mount -t davfs http://localhost:8080/ /data -o uid=1000,gid=1000,username=,password= && \
          echo "Bucket S3 mont√© sur /data" && \
          sleep infinity

üîë Points cl√©s

davfs2 permet de monter un serveur WebDAV comme un FS.

On monte http://localhost:8080/ (le sidecar rclone) dans /data.

L‚Äôoption uid=1000,gid=1000 garantit que ton user applicatif (app) est propri√©taire des fichiers.

Pas besoin de root permanent : seul le mount initial est root, mais comme c‚Äôest fait dans command, apr√®s c‚Äôest transparent.

‚ö†Ô∏è Attention

Certains clusters bloquent mount m√™me sans /dev/fuse ‚Üí √† tester.

davfs2 stocke parfois des fichiers de cache dans ~/.davfs2. Tu peux ignorer √ßa avec -o conf=/dev/null.

Performances moindres qu‚Äôun FS local (chaque lecture/√©criture passe par WebDAV ‚Üí HTTP ‚Üí S3).

üëâ Question : ton application a besoin de lire/√©crire beaucoup de petits fichiers fr√©quemment, ou plut√¥t des fichiers de taille moyenne/grosse (images, documents, logs) ?
Cela change beaucoup le choix optimal (WebDAV est bien pour fichiers moyens/gros, mais tr√®s mauvais pour plein de petits fichiers).




          
