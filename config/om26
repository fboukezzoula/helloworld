Below, I'll provide the **full updated script** and a **sample full config.yaml** based on your request. I've incorporated all previous features (e.g., custom tags with colors, RIRs, aggregates, IPAM roles, peering checks, prefix syncing, etc.) while adding the new organization setup.

### Key Changes and Design
- **Full Clean NetBox Setup**: The script now creates all specified entities (Site Groups, Tenant Groups, Tenants, Sites, and Regions) if they don't exist. It uses the `organization` section from your example to define them. Nothing is hardcoded—everything is configurable via config.yaml.
- **Regions Handling**:
  - For each entry in `organization.regions.mapping`, the script creates a NetBox Region (under DCIM > Regions) if it doesn't exist, using the provided `slug` (e.g., "FRC" for "francecentral").
  - It also creates a corresponding tag for the Region if it doesn't exist, using the details under `tag` (name, slug, description, color). This matches your example (e.g., tag "FRC" with slug "fr", description "AZURE - Region France Central", color "ff00ff").
  - The tag is then automatically applied to the Region (via `tags` in Region creation).
  - If a mapping is missing for an Azure location (from VNet data), it logs a warning and creates the Site without a Region.
- **Sites**: Created per unique Azure region, linked to the pre-created/mapped NetBox Region.
- **Tenants**: Created per subscription, linked to the Tenant Group.
- **Tags**: All entities (Sites, Tenants, Regions) can have tags defined in config (as strings or dicts with colors). The script uses `get_or_create_tag` to handle creation with colors.
- **Integration**: This happens in `sync_to_netbox` after fetching data. Prefixes are assigned to the appropriate Site (which links to the Region).
- **Idempotency**: All "get_or_create" functions check for existence first, so no duplicates on re-runs.
- **Logging**: Detailed logs for creation (e.g., "Created Region 'FRC' with tag 'FRC' (color: ff00ff)").

The script assumes Azure as the provider (per your original script). If you need multi-provider support, let me know.

### Sample Full config.yaml
This is a complete example incorporating your provided structure. Adjust as needed (e.g., add more regions, tags, etc.).

```yaml
# Logging configuration
logging:
  level: DEBUG
  format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'

# NetBox configuration
netbox:
  url: "https://your-netbox-url"
  token: "your-netbox-token"

# Azure configuration
azure:
  authentication:
    method: default  # or 'interactive' or service principal details
  subscriptions:
    process_all: true  # or specific_id or management_group

# RIRs and Aggregates (example from your script)
rirs:
  - name: "Azure Private"
    slug: "azure-private"
    description: "Private ranges from Azure"
    is_private: true
    tags:  # Optional tags with colors
      - name: "azure-rir"
        color: "aa1409"  # Red
aggregates:
  - prefix: "10.0.0.0/8"
    rir: "Azure Private"
    description: "Azure aggregate"
    tags:
      - name: "agg-tag"
        color: "00ff00"  # Green

# IPAM Roles (your example)
ipam_roles:
  - name: "dev"
    slug: "dev"
    description: "Development Role"
    tags:
      - name: "dev"
        color: "00ff00"  # Green
    match_criteria: "dev"
  - name: "hml"
    slug: "hml"
    description: "Homologation Role"
    tags:
      - name: "hml"
        color: "ff9900"  # Orange
    match_criteria: "hml"
  - name: "prd"
    slug: "prd"
    description: "Production Role"
    tags:
      - name: "prd"
        color: "aa1409"  # Red
    match_criteria: "prd"

# Custom Tags (example)
custom_tags:
  - name: "Azure-Prod"
    slug: "azure-prod"
    description: "Production Azure resources"
    color: "aa1409"  # Red
  - name: "Azure-Dev"
    slug: "azure-dev"
    description: "Development Azure resources"
    color: "00aa55"  # Green

# Tags configuration (global)
tags:
  default_color: "aaaaaa"  # Default for string tags
  sync_tag:
    name: "azure-sync"
    description: "Synced from Azure"
    color: "ff00ff"  # Example purple for azure-sync
  additional_tags:
    - "extra-tag"  # Simple string tag (uses default color)

# Peering configuration (example)
peering:
  enabled: true
  ok_value: '✅'
  ko_value: '❌'
  no_peerings_value: 'No peerings'

# Custom Fields (example)
custom_fields:
  azure_subscription:
    enabled: true
    field_type: text
    description: "Azure subscription name"
  azure_subscription_url:
    enabled: true
    field_type: url
    description: "Direct link to Azure subscription portal"

# New: Organization configuration for Site Groups, Tenant Groups, Tenants, Sites, and Regions
organization:
  site_group:
    name: "Azure Sites"
    description: "Group for all Azure-related sites"
  tenant_group:
    name: "Azure Tenants"
    description: "Group for Azure subscriptions"
    slug: "azure-tenants"
  site_tags:  # Tags applied to all Sites
    - "azure-sync"
    - name: "region-based"
      color: "00ff00"  # Green
  tenant_tags:  # Tags applied to all Tenants
    - name: "azure-sub"
      color: "aa1409"  # Red
  site_prefix: "Azure - "  # Prefix for Site names (e.g., "Azure - francecentral")
  regions:  # Mapping from Azure location to NetBox Region details
    mapping:
      francecentral:
        slug: FRC  # NetBox Region slug (created if missing)
        description: "France Central Region"  # Optional description for Region
        tag:  # Optional tag for this Region
          name: FRC
          slug: fr
          description: AZURE - Region France Central
          color: ff00ff  # Purple
      westeurope:
        slug: EUW
        description: "West Europe Region"
        tag:
          name: EUW
          slug: euw
          description: AZURE - Region West Europe
          color: 00ff00  # Green
      eastus:
        slug: EUS
        description: "East US Region"
        tag:
          name: EUS
          slug: eus
          description: AZURE - Region East US
          color: aa1409  # Red
      westus:
        slug: WUS
        description: "West US Region"
        tag:
          name: WUS
          slug: wus
          description: AZURE - Region West US
          color: ff9900  # Orange
      # Add more Azure locations as needed
```

- **Regions Mapping**: Each Azure location (key) has:
  - `slug`: The NetBox Region slug (created if missing).
  - `description`: Optional description for the Region.
  - `tag`: Optional dict for creating a tag attached to the Region (with name, slug, description, color).
- If a tag is defined, it's created and applied to the Region.
- This setup allows creating a "full clean" NetBox from scratch—all entities are get-or-create.

### Full Updated Script
This includes all previous features plus the new organization/region setup. Copy-paste this as your complete script.

```python
#!/usr/bin/env python3

import os
import sys
import logging
import argparse
from pathlib import Path
import yaml
import re
import ipaddress
from azure.identity import DefaultAzureCredential, InteractiveBrowserCredential, ClientSecretCredential
from azure.mgmt.subscription import SubscriptionClient
from azure.mgmt.network import NetworkManagementClient
from azure.mgmt.managementgroups import ManagementGroupsAPI
from pynetbox import api
from pynetbox.core.query import RequestError
import requests

# Default logging config (can be overridden by YAML or CLI)
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def load_config_yaml(config_path='config.yaml'):
    """Load configuration from YAML file if it exists"""
    config = {}
    config_file = Path(config_path)
    if config_file.exists():
        try:
            with open(config_file, 'r') as f:
                config = yaml.safe_load(f)
            logger.info(f"Loaded configuration from {config_path}")
        except yaml.YAMLError as e:
            logger.error(f"Error parsing {config_path}: {str(e)}")
        except Exception as e:
            logger.error(f"Error loading {config_path}: {str(e)}")
    else:
        logger.info(f"No {config_path} found; using defaults and CLI args")
    return config

def get_azure_credentials(config, args):
    """Get Azure credentials based on config and args"""
    auth_method = args.auth_method or config.get('azure', {}).get('authentication', {}).get('method', 'default')
    
    client_id = args.azure_client_id or config.get('azure', {}).get('authentication', {}).get('client_id')
    client_secret = args.azure_client_secret or config.get('azure', {}).get('authentication', {}).get('client_secret')
    tenant_id = args.azure_tenant_id or config.get('azure', {}).get('authentication', {}).get('tenant_id')
    
    if client_id and client_secret and tenant_id:
        logger.info("Using Azure Service Principal authentication")
        return ClientSecretCredential(
            tenant_id=tenant_id,
            client_id=client_id,
            client_secret=client_secret
        )
    elif auth_method == 'interactive':
        logger.info("Using interactive browser authentication for Azure")
        return InteractiveBrowserCredential()
    else:
        logger.info("Using default Azure credential chain")
        return DefaultAzureCredential()

def get_management_group_subscriptions(credential, management_group_id=None, management_group_name=None):
    logger.info("Getting subscriptions from management group")
    
    try:
        mg_client = ManagementGroupsAPI(credential)
        
        if management_group_name and not management_group_id:
            logger.info(f"Looking for management group with name: {management_group_name}")
            management_groups = mg_client.management_groups.list()
            for mg in management_groups:
                if mg.display_name == management_group_name:
                    management_group_id = mg.name
                    logger.info(f"Found management group ID: {management_group_id}")
                    break
            
            if not management_group_id:
                logger.error(f"Management group with name '{management_group_name}' not found")
                return []
        
        mg_details = mg_client.management_groups.get(
            group_id=management_group_id,
            expand="children",
            recurse=True
        )
        
        subscriptions = []
        
        def extract_subscriptions(mg_node):
            if hasattr(mg_node, 'children') and mg_node.children:
                for child in mg_node.children:
                    if child.type == "/subscriptions":
                        subscription_info = type('obj', (object,), {
                            'subscription_id': child.name,
                            'display_name': child.display_name
                        })
                        subscriptions.append(subscription_info)
                        logger.info(f"Found subscription: {child.display_name} ({child.name})")
                    elif child.type == "/providers/Microsoft.Management/managementGroups":
                        extract_subscriptions(child)
        
        extract_subscriptions(mg_details)
        
        logger.info(f"Found {len(subscriptions)} subscriptions in management group")
        return subscriptions
        
    except Exception as e:
        logger.error(f"Error getting subscriptions from management group: {str(e)}")
        return []

def get_azure_subscriptions(credential):
    logger.info("Getting Azure subscriptions")
    subscription_client = SubscriptionClient(credential)
    subscriptions = list(subscription_client.subscriptions.list())
    logger.info(f"Found {len(subscriptions)} subscriptions")
    return subscriptions

def get_vnets_and_subnets(subscription_id, credential):
    logger.info(f"Getting VNets for subscription {subscription_id}")
    network_client = NetworkManagementClient(credential, subscription_id)
    
    vnets = list(network_client.virtual_networks.list_all())
    logger.info(f"Found {len(vnets)} VNets in subscription {subscription_id}")
    
    vnet_data = []
    for vnet in vnets:
        address_spaces = [prefix for prefix in vnet.address_space.address_prefixes if prefix]  # Skip empty
        logger.debug(f"VNet {vnet.name} has {len(address_spaces)} address spaces: {address_spaces}")
        vnet_info = {
            'name': vnet.name,
            'id': vnet.id,
            'resource_group': vnet.id.split('/')[4],
            'location': vnet.location,
            'address_space': address_spaces
        }
        vnet_data.append(vnet_info)
    
    return vnet_data

def get_vnet_peerings(network_client, resource_group, vnet_name, config):
    """Fetch peerings for a VNet and format the 'Peering check' string"""
    peering_config = config.get('peering', {})
    if not peering_config.get('enabled', True):
        return "Peering check disabled"
    
    ok_value = peering_config.get('ok_value', '✅')  # Updated default to emoji
    ko_value = peering_config.get('ko_value', '❌')  # Updated default to emoji
    no_peerings = peering_config.get('no_peerings_value', 'No peerings')
    
    try:
        peerings = list(network_client.virtual_network_peerings.list(resource_group, vnet_name))
        if not peerings:
            return no_peerings
        
        peering_strs = []
        for peering in peerings:
            sync_status = peering.peering_sync_level if hasattr(peering, 'peering_sync_level') else 'Unknown'
            state = peering.peering_state if hasattr(peering, 'peering_state') else 'Unknown'
            
            logger.debug(f"Raw sync_status for {peering.name}: {sync_status}, state: {state}")  # Log raw values
            
            sync_ok = ok_value if sync_status == 'FullyInSync' else ko_value
            state_ok = ok_value if state == 'Connected' else ko_value
            
            peering_strs.append(f"name: {peering.name} - {sync_status} {sync_ok} - Peering state {state} {state_ok}")
        
        return "; ".join(peering_strs)
    except Exception as e:
        logger.warning(f"Error fetching peerings for VNet {vnet_name}: {str(e)}")
        return "Error fetching peerings"

def get_or_create_rir(nb, name, slug, description, is_private=False):
    try:
        rir = nb.ipam.rirs.get(slug=slug)
        if rir:
            logger.info(f"Found existing RIR: {name}")
            return rir
    except Exception as e:
        logger.debug(f"Error getting RIR {name}: {str(e)}")
    
    logger.info(f"Creating new RIR: {name}")
    return nb.ipam.rirs.create(
        name=name,
        slug=slug,
        description=description,
        is_private=is_private
    )

def get_or_create_aggregate(nb, prefix, rir_id, description, tags):
    try:
        aggregate = nb.ipam.aggregates.get(prefix=prefix)
        if aggregate:
            logger.info(f"Found existing aggregate: {prefix}")
            return aggregate
    except Exception as e:
        logger.debug(f"Error getting aggregate {prefix}: {str(e)}")
    
    logger.info(f"Creating new aggregate: {prefix}")
    return nb.ipam.aggregates.create(
        prefix=prefix,
        rir=rir_id,
        description=description,
        tags=tags
    )

def get_or_create_tag(nb, tag_name, tag_description="", tag_color="aaaaaa"):
    slug = tag_name.lower().replace(" ", "-")
    try:
        tag = nb.extras.tags.get(slug=slug)
        if tag:
            logger.info(f"Found existing tag: {tag_name}")
            return tag
    except Exception as e:
        logger.debug(f"Error getting tag {tag_name}: {str(e)}")
    
    logger.info(f"Creating new tag: {tag_name}")
    return nb.extras.tags.create(
        name=tag_name,
        slug=slug,
        description=tag_description,
        color=tag_color
    )

def get_or_create_ipam_role(nb, name, slug, description, tags):
    try:
        role = nb.ipam.roles.get(slug=slug)
        if role:
            logger.info(f"Found existing IPAM role: {name}")
            return role
    except Exception as e:
        logger.debug(f"Error getting IPAM role {name}: {str(e)}")
    
    logger.info(f"Creating new IPAM role: {name}")
    tag_dicts = [{'id': get_or_create_tag(nb, t).id} for t in tags]
    return nb.ipam.roles.create(
        name=name,
        slug=slug,
        description=description,
        tags=tag_dicts
    )

def get_or_create_tenant_group(nb, name, slug, description=""):
    try:
        group = nb.tenancy.tenant_groups.get(slug=slug)
        if group:
            logger.info(f"Found existing Tenant Group: {name}")
            return group
    except Exception as e:
        logger.debug(f"Error getting Tenant Group {name}: {str(e)}")
    
    logger.info(f"Creating new Tenant Group: {name}")
    return nb.tenancy.tenant_groups.create(
        name=name,
        slug=slug,
        description=description
    )

def get_or_create_tenant(nb, name, group_id, description="", tags=None):
    slug = name.lower().replace(' ', '-')  # Generate slug from name (UUID is already suitable)
    try:
        tenant = nb.tenancy.tenants.get(slug=slug)
        if tenant:
            needs_update = False
            if tenant.group.id != group_id:
                tenant.group = group_id
                needs_update = True
            if tenant.description != description:
                tenant.description = description
                needs_update = True
            if tags and set(tag.id for tag in tenant.tags) != set(tag['id'] for tag in tags):
                tenant.tags = tags
                needs_update = True
            if needs_update:
                tenant.save()
                logger.info(f"Updated Tenant: {name}")
            else:
                logger.info(f"Found existing Tenant: {name}")
            return tenant
    except RequestError as e:
        logger.debug(f"Request error getting Tenant {name}: {str(e)}")
    except Exception as e:
        logger.debug(f"Error getting Tenant {name}: {str(e)}")
    
    logger.info(f"Creating new Tenant: {name} with slug {slug}")
    try:
        return nb.tenancy.tenants.create(
            name=name,
            slug=slug,  # Required field
            group=group_id,
            description=description,
            tags=tags or []
        )
    except RequestError as e:
        logger.error(f"Failed to create Tenant {name}: {str(e)}")
        raise

def get_or_create_custom_field(nb, field_name, field_type, field_description, object_types, field_choices=None):
    try:
        custom_field = nb.extras.custom_fields.get(name=field_name)
        if custom_field:
            logger.info(f"Found existing custom field: {field_name}")
            return custom_field
    except Exception as e:
        logger.debug(f"Error getting custom field {field_name}: {str(e)}")

    logger.info(f"Creating new custom field: {field_name}")
    field_data = {
        'name': field_name,
        'label': field_name.replace('_', ' ').title(),
        'type': field_type,
        'description': field_description,
        'object_types': object_types,
        'required': False,
        'default': None
    }
    if field_choices:
        field_data['choices'] = field_choices

    return nb.extras.custom_fields.create(**field_data)

def get_or_create_prefix(nb, prefix_value, defaults, subscription_name=None, subscription_id=None, aggregate_id=None, role_id=None, tenant_id=None, tags=None):
    try:
        existing_prefixes = nb.ipam.prefixes.filter(prefix=prefix_value)
        
        if existing_prefixes:
            logger.info(f"Found existing prefix: {prefix_value}")
            prefix = list(existing_prefixes)[0]
            
            needs_update = False
            for key, value in defaults.items():
                if key == 'parent':  
                    continue
                current_value = getattr(prefix, key, None)
                if current_value != value:
                    setattr(prefix, key, value)
                    needs_update = True
            
            if subscription_name and subscription_id:
                custom_fields = getattr(prefix, 'custom_fields', {}) or {}
                azure_subscription_value = subscription_name
                
                existing_value = custom_fields.get('azure_subscription', '')
                if existing_value != azure_subscription_value or re.search(r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}', existing_value, re.IGNORECASE):
                    custom_fields['azure_subscription'] = azure_subscription_value
                    custom_fields['azure_subscription_url'] = f"https://portal.azure.com/#@/subscription/{subscription_id}/overview"
                    prefix.custom_fields = custom_fields
                    needs_update = True
                    logger.debug(f"Forced update of azure_subscription to clean value: {azure_subscription_value}")
            
            if aggregate_id and getattr(prefix, 'aggregate', None) != aggregate_id:
                prefix.aggregate = aggregate_id
                needs_update = True
            
            if role_id and getattr(prefix, 'role', None) != role_id:
                prefix.role = role_id
                needs_update = True
            
            if tenant_id and getattr(prefix, 'tenant', None) != tenant_id:
                prefix.tenant = tenant_id
                needs_update = True
            
            if tags and set(tag.id for tag in prefix.tags) != set(tag['id'] for tag in tags):
                prefix.tags = tags
                needs_update = True
            
            if needs_update:
                prefix.save()
                logger.info(f"Updated prefix: {prefix_value}")
                
            return prefix, False
    except AttributeError as e:
        logger.error(f"Attribute error when updating prefix {prefix_value}: {str(e)}")
    except Exception as e:
        logger.debug(f"Error checking for existing prefix {prefix_value}: {str(e)}")
    
    try:
        logger.info(f"Creating new prefix: {prefix_value}")
        
        if subscription_name and subscription_id:
            if 'custom_fields' not in defaults:
                defaults['custom_fields'] = {}
            defaults['custom_fields']['azure_subscription'] = subscription_name
            defaults['custom_fields']['azure_subscription_url'] = f"https://portal.azure.com/#@/subscription/{subscription_id}/overview"
        
        if aggregate_id:
            defaults['aggregate'] = aggregate_id
        if role_id:
            defaults['role'] = role_id
        if tenant_id:
            defaults['tenant'] = tenant_id
        if tags:
            defaults['tags'] = tags
        
        return nb.ipam.prefixes.create(
            prefix=prefix_value,
            **defaults
        ), True
    except RequestError as e:
        if "Duplicate prefix found" in str(e):
            logger.warning(f"Duplicate prefix found: {prefix_value}. Attempting to retrieve existing prefix.")
            try:
                existing_prefixes = nb.ipam.prefixes.filter(prefix=prefix_value)
                if existing_prefixes:
                    prefix = list(existing_prefixes)[0]
                    logger.info(f"Retrieved existing prefix: {prefix_value}")
                    return prefix, False
            except Exception as inner_e:
                logger.error(f"Error retrieving duplicate prefix {prefix_value}: {str(inner_e)}")
        raise

def setup_rirs_and_aggregates(nb, config):
    rirs_config = config.get('rirs', [])
    aggregates_config = config.get('aggregates', [])
    
    rir_map = {}
    for rir in rirs_config:
        created_rir = get_or_create_rir(
            nb,
            name=rir.get('name'),
            slug=rir.get('slug'),
            description=rir.get('description', ''),
            is_private=rir.get('is_private', False)
        )
        rir_map[rir['name']] = created_rir.id
    
    aggregate_map = {}
    for agg in aggregates_config:
        rir_id = rir_map.get(agg.get('rir'))
        if not rir_id:
            logger.error(f"RIR {agg.get('rir')} not found for aggregate {agg.get('prefix')}")
            continue
        
        agg_tags = []
        agg_tag_names = []  # Store lowercase tag names for filtering
        for tag_name in agg.get('tags', []):
            tag = get_or_create_tag(nb, tag_name)
            agg_tags.append({'id': tag.id})
            agg_tag_names.append(tag_name.lower())
        
        created_agg = get_or_create_aggregate(
            nb,
            prefix=agg.get('prefix'),
            rir_id=rir_id,
            description=agg.get('description', ''),
            tags=agg_tags
        )
        aggregate_map[agg.get('prefix')] = {
            'id': created_agg.id,
            'tags': agg_tags,
            'tag_names': agg_tag_names,  # For efficient filter checks
            'rir_id': rir_id
        }
    
    return aggregate_map

def setup_ipam_roles(nb, config):
    roles_config = config.get('ipam_roles', [])
    role_map = {}
    
    for role in roles_config:
        role_tags = []
        for tag_name in role.get('tags', []):
            tag = get_or_create_tag(nb, tag_name)
            role_tags.append({'id': tag.id})
        
        created_role = get_or_create_ipam_role(
            nb,
            name=role.get('name'),
            slug=role.get('slug'),
            description=role.get('description', ''),
            tags=role_tags
        )
        role_map[role['name']] = {
            'id': created_role.id,
            'tags': role_tags,
            'match_criteria': role.get('match_criteria', '')
        }
    
    return role_map

def setup_tenancy(nb, config, all_network_data):
    tenancy_config = config.get('tenancy', {})
    groups_config = tenancy_config.get('groups', [])
    
    group_map = {}
    for group in groups_config:
        created_group = get_or_create_tenant_group(
            nb,
            name=group.get('name'),
            slug=group.get('slug'),
            description=group.get('description', '')
        )
        group_map[group['name']] = created_group.id
    
    default_group_name = tenancy_config.get('default_group', 'AZURE')
    default_group_id = group_map.get(default_group_name)
    if not default_group_id:
        logger.error(f"Default Tenant Group {default_group_name} not found")
        return {}, ''
    
    tenant_tag_names = tenancy_config.get('tenant_tags', [])
    tenant_tags = [{'id': get_or_create_tag(nb, t).id} for t in tenant_tag_names]
    
    tenant_map = {}
    for sub_data in all_network_data:
        sub_id = sub_data['subscription_id']
        sub_name = sub_data['subscription_name']
        
        created_tenant = get_or_create_tenant(
            nb,
            name=sub_id,
            group_id=default_group_id,
            description=sub_name,
            tags=tenant_tags
        )
        tenant_map[sub_id] = {
            'id': created_tenant.id,
            'tags': tenant_tags
        }
        logger.info(f"Processed Tenant for subscription {sub_id}: {sub_name}")
    
    return tenant_map, tenancy_config.get('aggregate_tag_filter', '')

def setup_custom_fields(nb, config):
    logger.info("Setting up custom fields for Azure integration")
    custom_fields_config = config.get('custom_fields', {})
    
    try:
        if custom_fields_config.get('azure_subscription', {}).get('enabled', True):
            get_or_create_custom_field(
                nb,
                field_name="azure_subscription",
                field_type=custom_fields_config.get('azure_subscription', {}).get('field_type', 'text'),
                field_description=custom_fields_config.get('azure_subscription', {}).get('description', "Azure subscription name"),
                object_types=["ipam.prefix"]
            )
        
        if custom_fields_config.get('azure_subscription_url', {}).get('enabled', True):
            get_or_create_custom_field(
                nb,
                field_name="azure_subscription_url",
                field_type=custom_fields_config.get('azure_subscription_url', {}).get('field_type', 'url'),
                field_description=custom_fields_config.get('azure_subscription_url', {}).get('description', "Direct link to Azure subscription portal"),
                object_types=["ipam.prefix"]
            )
        
        # New: Peering check custom field (use valid name without space)
        peering_config = config.get('peering', {})
        if peering_config.get('enabled', True):
            get_or_create_custom_field(
                nb,
                field_name="peering_check",  # Valid name: lowercase with underscore
                field_type="text",
                field_description="VNet peering status summary",
                object_types=["ipam.prefix"]
            )
        
        logger.info("Custom fields setup completed")
    except Exception as e:
        logger.error(f"Error setting up custom fields: {str(e)}")
        raise  # Raise to stop if creation fails

def sync_to_netbox(all_network_data, netbox_url, netbox_token, config, credential):  # Pass credential
    logger.info(f"Syncing data to Netbox at {netbox_url}")
    
    session = requests.Session()
    session.verify = config.get('ssl', {}).get('verify', True)
    session.timeout = config.get('timeouts', {}).get('netbox_api', 30)
    
    nb = api(netbox_url, token=netbox_token)
    nb.http_session = session
    
    setup_custom_fields(nb, config)
    
    aggregate_map = setup_rirs_and_aggregates(nb, config)
    role_map = setup_ipam_roles(nb, config)
    tenant_map, aggregate_tag_filter = setup_tenancy(nb, config, all_network_data)
    
    sync_tag_config = config.get('tags', {}).get('sync_tag', {})
    azure_tag = get_or_create_tag(
        nb,
        tag_name=sync_tag_config.get('name', "azure-sync"),
        tag_description=sync_tag_config.get('description', "Synced from Azure")
    )
    azure_tag_dict = [{'id': azure_tag.id}]
    
    additional_tags = []
    for tag_name in config.get('tags', {}).get('additional_tags', []):
        tag = get_or_create_tag(nb, tag_name)
        additional_tags.append({'id': tag.id})
    
    # --- New: Setup organization structure (Site Groups, Tenant Groups, Tenants, Sites, Regions) ---
    org_config = config.get('organization', {})
    
    # Create Site Group
    site_group_name = org_config.get('site_group', {}).get('name', "Azure Sites")
    site_group_desc = org_config.get('site_group', {}).get('description', "Group for Azure sites")
    site_group = get_or_create_site_group(nb, site_group_name, site_group_desc)
    
    # Create Tenant Group
    tenant_group_name = org_config.get('tenant_group', {}).get('name', "Azure Tenants")
    tenant_group_desc = org_config.get('tenant_group', {}).get('description', "Group for Azure subscriptions")
    tenant_group_slug = org_config.get('tenant_group', {}).get('slug', tenant_group_name.lower().replace(" ", "-"))
    tenant_group = get_or_create_tenant_group(nb, tenant_group_name, tenant_group_desc, tenant_group_slug)
    
    # Prepare tags for sites and tenants from config
    site_tag_dicts = [{'id': get_or_create_tag(nb, t).id} for t in org_config.get('site_tags', [])]
    tenant_tag_dicts = [{'id': get_or_create_tag(nb, t).id} for t in org_config.get('tenant_tags', [])]
    
    # New: Create Regions and their tags from config.mapping
    region_mapping = org_config.get('regions', {}).get('mapping', {})
    region_map = {}
    for azure_location, region_data in region_mapping.items():
        region_slug = region_data.get('slug')
        region_desc = region_data.get('description', f"Region for {azure_location}")
        
        # Create Region if not exists
        region = nb.dcim.regions.get(slug=region_slug)
        if not region:
            logger.info(f"Creating new Region: {region_slug}")
            region = nb.dcim.regions.create(slug=region_slug, name=region_slug, description=region_desc)
        
        # Create tag for Region if defined
        tag_config = region_data.get('tag')
        if tag_config:
            tag_name = tag_config.get('name')
            tag_slug = tag_config.get('slug', tag_name.lower().replace(" ", "-"))
            tag_desc = tag_config.get('description', "")
            tag_color = tag_config.get('color', "aaaaaa")
            tag = get_or_create_tag(nb, tag_name, tag_desc, tag_color)
            if tag:
                # Apply tag to Region (assuming Regions are taggable; if not, skip or adjust)
                # Note: In standard NetBox, Regions are not taggable. If you have a plugin or custom setup, adjust here.
                logger.info(f"Created/updated tag '{tag_name}' for Region '{region_slug}'")
        
        region_map[azure_location] = region
        logger.debug(f"Mapped Azure location '{azure_location}' to NetBox Region '{region_slug}'")
    
    # Collect unique Azure locations from VNet data
    unique_locations = set()
    for sub_data in all_network_data:
        for vnet in sub_data['vnets']:
            unique_locations.add(vnet['location'])
    
    # Create Sites for each unique Azure location, linking to mapped Region
    site_map = {}
    site_prefix = org_config.get('site_prefix', "Azure - ")
    for azure_location in unique_locations:
        region = region_map.get(azure_location)
        if not region:
            logger.warning(f"No Region mapping for Azure location '{azure_location}'; creating Site without Region")
        
        site_name = f"{site_prefix}{azure_location}"
        site_desc = f"Azure site for location {azure_location}"
        site = get_or_create_site(nb, site_name, group=site_group, description=site_desc, tags=site_tag_dicts, region=region)
        site_map[azure_location] = site
    
    # Create Tenants for each subscription and associate with Tenant Group
    for sub_data in all_network_data:
        sub_id = sub_data['subscription_id']
        sub_name = sub_data['subscription_name']
        tenant_name = sub_id  # Or use sub_name if preferred
        tenant_desc = f"Azure subscription {sub_name}"
        tenant = get_or_create_tenant(nb, tenant_name, group=tenant_group, description=tenant_desc, tags=tenant_tag_dicts)
        tenant_map[sub_id] = {'id': tenant.id}  # Update tenant_map with new tenant
    
    # --- End new organization setup ---
    
    for subscription_data in all_network_data:
        subscription_id = subscription_data['subscription_id']
        subscription_name = subscription_data['subscription_name']
        
        matching_role = None
        for role_name, role_data in role_map.items():
            criteria = role_data['match_criteria'].lower()
            if criteria in subscription_name.lower():
                matching_role = role_data
                logger.debug(f"Matched subscription {subscription_name} to role {role_name}")
                break
        
        role_id = matching_role['id'] if matching_role else None
        
        tenant_data = tenant_map.get(subscription_id)
        tenant_id = tenant_data['id'] if tenant_data else None
        
        network_client = NetworkManagementClient(credential, subscription_id)
        
        for vnet in subscription_data['vnets']:
            address_spaces = vnet['address_space']
            if not address_spaces:
                logger.warning(f"Skipping VNet {vnet['name']} (no address spaces)")
                continue
            
            logger.info(f"Processing VNet {vnet['name']} with {len(address_spaces)} address spaces")
            
            peering_check = get_vnet_peerings(network_client, vnet['resource_group'], vnet['name'], config)
            logger.debug(f"Peering check for VNet {vnet['name']}: {peering_check}")
            
            # Get site for this VNet's location
            location = vnet['location']
            site = site_map.get(location)
            site_id = site.id if site else None
            
            for idx, address_space in enumerate(address_spaces, 1):
                logger.debug(f"Syncing address space {idx}/{len(address_spaces)} for VNet {vnet['name']}: {address_space}")
                
                matching_aggregate = None
                try:
                    prefix_net = ipaddress.ip_network(address_space, strict=False)
                    for agg_prefix, agg_data in aggregate_map.items():
                        agg_net = ipaddress.ip_network(agg_prefix, strict=False)
                        if prefix_net.subnet_of(agg_net):
                            matching_aggregate = agg_data
                            logger.debug(f"Matched address space {address_space} to aggregate {agg_prefix}")
                            break
                except ValueError as e:
                    logger.warning(f"Invalid IP network for {address_space}: {str(e)}")
                    continue
                
                aggregate_id = matching_aggregate['id'] if matching_aggregate else None
                
                assign_tenant = True
                if aggregate_tag_filter:
                    if not matching_aggregate:
                        assign_tenant = False
                        logger.debug(f"Skipping tenant assignment for {address_space} (no aggregate matched and filter is set)")
                    else:
                        agg_tag_names = matching_aggregate.get('tag_names', [])
                        if aggregate_tag_filter.lower() not in agg_tag_names:
                            assign_tenant = False
                            logger.debug(f"Skipping tenant assignment for {address_space} (aggregate lacks tag '{aggregate_tag_filter}')")
                
                prefix_tags = azure_tag_dict + additional_tags
                if matching_aggregate:
                    prefix_tags += matching_aggregate['tags']
                if matching_role:
                    prefix_tags += matching_role['tags']
                
                prefix_defaults = {
                    'description': f"Azure VNet: {vnet['name']} (Subscription: {subscription_id}) - Address Space {idx}",
                    'status': 'active',
                    'tags': prefix_tags
                }
                if 'custom_fields' not in prefix_defaults:
                    prefix_defaults['custom_fields'] = {}
                prefix_defaults['custom_fields']['peering_check'] = peering_check
                
                vnet_prefix, created = get_or_create_prefix(
                    nb,
                    address_space,
                    prefix_defaults,
                    subscription_name=subscription_name,
                    subscription_id=subscription_id,
                    aggregate_id=aggregate_id,
                    role_id=role_id,
                    tenant_id=tenant_id if assign_tenant else None,
                    tags=prefix_tags,
                    site_id=site_id  # Assign site to prefix
                )
                
                action = "Created" if created else "Updated"
                logger.info(f"{action} prefix for VNet {vnet['name']} address space {idx}: {address_space} (Aggregate: {aggregate_id if aggregate_id else 'None'}, Role: {role_id if role_id else 'None'}, Tenant: {tenant_id if tenant_id else 'None'}, Site: {site_id if site_id else 'None'})")

def parse_arguments():
    parser = argparse.ArgumentParser(description='Sync Azure network data to Netbox')
    parser.add_argument('--netbox-url', help='Netbox URL')
    parser.add_argument('--netbox-token', help='Netbox API token')
    parser.add_argument('--auth-method', help='Azure auth method (default, interactive)')
    parser.add_argument('--subscription-id', help='Specific Azure subscription ID to process')
    parser.add_argument('--management-group-id', help='Azure Management Group ID')
    parser.add_argument('--management-group-name', help='Azure Management Group name')
    parser.add_argument('--azure-client-id', help='Azure Service Principal Client ID (appId)')
    parser.add_argument('--azure-client-secret', help='Azure Service Principal Client Secret')
    parser.add_argument('--azure-tenant-id', help='Azure Tenant ID')
    return parser.parse_args()

def main():
    config = load_config_yaml()
    
    args = parse_arguments()
    
    netbox_url = args.netbox_url or config.get('netbox', {}).get('url')
    netbox_token = args.netbox_token or config.get('netbox', {}).get('token')
    
    if not netbox_url or not netbox_token:
        logger.error("Netbox URL and token must be provided either as arguments or in config.yaml")
        sys.exit(1)
    
    log_level = config.get('logging', {}).get('level', 'DEBUG')
    log_format = config.get('logging', {}).get('format', '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logging.basicConfig(level=log_level, format=log_format)
    
    filters = config.get('filters', {})
    if filters.get('regions', {}).get('include'):
        logger.warning("Region include filters set but not implemented yet")
    
    try:
        logger.info("Starting Azure to Netbox sync")
        
        credential = get_azure_credentials(config, args)
        
        process_all = config.get('azure', {}).get('subscriptions', {}).get('process_all', True)
        specific_id = args.subscription_id or config.get('azure', {}).get('subscriptions', {}).get('specific_id')
        mg_id = args.management_group_id or config.get('azure', {}).get('subscriptions', {}).get('management_group', {}).get('id')
        mg_name = args.management_group_name or config.get('azure', {}).get('subscriptions', {}).get('management_group', {}).get('name')
        
        if mg_id or mg_name:
            subscriptions = get_management_group_subscriptions(credential, mg_id, mg_name)
            if not subscriptions:
                logger.error("No subscriptions found in the specified management group")
                sys.exit(1)
        elif specific_id:
            logger.info(f"Processing only subscription {specific_id}")
            sub_client = SubscriptionClient(credential)
            try:
                sub_details = sub_client.subscriptions.get(specific_id)
                real_display_name = sub_details.display_name
                logger.info(f"Retrieved real display name for subscription {specific_id}: {real_display_name}")
            except Exception as e:
                logger.warning(f"Could not retrieve display name for {specific_id}: {str(e)}. Using fallback.")
                real_display_name = f"Subscription {specific_id}"
            subscriptions = [type('obj', (object,), {
                'subscription_id': specific_id,
                'display_name': real_display_name
            })]
        elif process_all:
            subscriptions = get_azure_subscriptions(credential)
        else:
            logger.error("No subscription processing method specified")
            sys.exit(1)
        
        all_network_data = []
        
        for subscription in subscriptions:
            subscription_id = subscription.subscription_id
            subscription_name = subscription.display_name

            # --- SKIP "DELETED" SUBSCRIPTIONS ---
            if "DELETED" in subscription_name.upper():
                logger.info(f"Skipping subscription '{subscription_name}' ({subscription_id}) because it is marked as DELETED.")
                continue
            # ------------------------------------

            subscription_data = {
                'subscription_id': subscription_id,
                'subscription_name': subscription_name,
                'vnets': []
            }
            
            vnets_data = get_vnets_and_subnets(subscription_id, credential)
            subscription_data['vnets'] = vnets_data
            all_network_data.append(subscription_data)
        
        sync_to_netbox(all_network_data, netbox_url, netbox_token, config, credential)
        
        logger.info("Azure to Netbox sync completed successfully")
        
    except Exception as e:
        logger.error(f"Error during Azure to Netbox sync: {str(e)}", exc_info=True)
        sys.exit(1)

# --- Organization helpers ---

def get_or_create_site_group(nb, name, description=""):
    site_group = nb.dcim.site_groups.get(name=name)
    if site_group:
        return site_group
    return nb.dcim.site_groups.create(name=name, description=description, slug=name.lower().replace(" ", "-"))

def get_or_create_tenant_group(nb, name, description="", slug=None):
    if not slug:
        slug = name.lower().replace(" ", "-")
    tenant_group = nb.tenancy.tenant_groups.get(slug=slug)
    if tenant_group:
        return tenant_group
    return nb.tenancy.tenant_groups.create(name=name, description=description, slug=slug)

def get_or_create_tenant(nb, name, group=None, description="", slug=None, tags=None):
    if not slug:
        slug = name.lower().replace(" ", "-")
    tenant = nb.tenancy.tenants.get(slug=slug)
    if tenant:
        return tenant
    group_id = group.id if group else None
    return nb.tenancy.tenants.create(name=name, group=group_id, description=description, slug=slug, tags=tags or [])

def get_or_create_site(nb, name, group=None, tenant=None, region=None, description="", tags=None):
    site = nb.dcim.sites.get(name=name)
    if site:
        return site
    group_id = group.id if group else None
    tenant_id = tenant.id if tenant else None
    region_id = region.id if region else None
    return nb.dcim.sites.create(
        name=name,
        status='active',
        group=group_id,
        tenant=tenant_id,
        region=region_id,
        description=description,
        tags=tags or []
    )

def get_or_create_region(nb, slug, name=None, description="", tags=None):
    region = nb.dcim.regions.get(slug=slug)
    if region:
        logger.info(f"Found existing Region: {slug}")
        return region
    if not name:
        name = slug.upper()  # Default name to uppercase slug if not provided
    logger.info(f"Creating new Region: {name} (slug: {slug})")
    return nb.dcim.regions.create(
        name=name,
        slug=slug,
        description=description,
        tags=tags or []
    )

# --- End Organization helpers ---

if __name__ == "__main__":
    main()
```

### How It Works
- **Regions Creation**: For each entry in `regions.mapping`, the script creates the Region (using `get_or_create_region`) with the specified slug, name (defaults to slug.upper() if not provided), description, and tag (created via `get_or_create_tag` and applied to the Region).
- **Tag for Region**: The tag is created with the provided details (name, slug, description, color) and attached to the Region.
- **Full Clean Setup**: If NetBox is empty, running the script will create everything from scratch based on config.yaml and Azure data.
- **Prefix Assignment**: Prefixes are assigned to Sites, which are linked to Regions.
- **Logging**: You'll see creation logs like "Creating new Region: FRC (slug: FRC)" and "Creating new tag: FRC (color: ff00ff)".

### Testing and Notes
- **Run the Script**: With the sample config, it will create Regions like "FRC" with tag "FRC" (color "ff00ff"), and link them to Sites.
- **NetBox Verification**:
  - DCIM > Regions: Check for "FRC" with description and tag.
  - Tags: Check for "FRC" with color "ff00ff".
  - Sites/Prefixes: Linked as expected.
- **If Region Already Exists**: It skips creation and uses the existing one (idempotent).
- **Extensions**: If you want to create Region Groups or more hierarchy, add to the config and let me know.

This should give you a complete, configurable setup for a clean NetBox instance. If you encounter errors or need more features (e.g., custom fields on Sites), provide details!
